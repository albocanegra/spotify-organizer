<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spotify Artist Organizer</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, sans-serif; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script>
    const { useState, useEffect, createElement: h } = React;

    function generateRandomString(length) {
      const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      const values = crypto.getRandomValues(new Uint8Array(length));
      let result = '';
      for (let i = 0; i < length; i++) {
        result += possible[values[i] % possible.length];
      }
      return result;
    }

    function sha256(plain) {
      const encoder = new TextEncoder();
      const data = encoder.encode(plain);
      return window.crypto.subtle.digest('SHA-256', data);
    }

    function base64encode(input) {
      return btoa(String.fromCharCode.apply(null, new Uint8Array(input)))
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
    }

    const SpotifyOrganizer = () => {
      const [accessToken, setAccessToken] = useState(null);
      const [userId, setUserId] = useState(null);
      const [artists, setArtists] = useState([]);
      const [categories, setCategories] = useState({ 'Uncategorized': [] });
      const [loading, setLoading] = useState(false);
      const [newCategoryName, setNewCategoryName] = useState('');
      const [showNewCategory, setShowNewCategory] = useState(false);
      const [syncing, setSyncing] = useState(false);
      const [statusMessage, setStatusMessage] = useState('');

      const CLIENT_ID = 'e21bf88870a94703bc0cdcf317075a5e';
      const REDIRECT_URI = 'https://albocanegra.github.io/spotify-organizer';
      const SCOPES = 'user-follow-read playlist-read-private playlist-modify-private playlist-modify-public';
      
      const CATEGORY_PREFIX = '__ARTIST_CATEGORY__';

      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const code = params.get('code');
        
        if (code) {
          exchangeCodeForToken(code);
        }

        const token = localStorage.getItem('spotify_access_token');
        const expiry = localStorage.getItem('spotify_token_expiry');
        
        if (token && expiry && Date.now() < parseInt(expiry)) {
          setAccessToken(token);
          initializeApp(token);
        }
      }, []);

      const showStatus = (message, duration = 3000) => {
        setStatusMessage(message);
        setTimeout(() => setStatusMessage(''), duration);
      };

      const handleLogin = () => {
        const codeVerifier = generateRandomString(64);
        sha256(codeVerifier).then((hashed) => {
          const codeChallenge = base64encode(hashed);
          localStorage.setItem('code_verifier', codeVerifier);

          const authUrl = new URL('https://accounts.spotify.com/authorize');
          const params = {
            client_id: CLIENT_ID,
            response_type: 'code',
            redirect_uri: REDIRECT_URI,
            scope: SCOPES,
            code_challenge_method: 'S256',
            code_challenge: codeChallenge,
          };

          authUrl.search = new URLSearchParams(params).toString();
          window.location.href = authUrl.toString();
        });
      };

      const exchangeCodeForToken = (code) => {
        setLoading(true);
        const codeVerifier = localStorage.getItem('code_verifier');

        fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            client_id: CLIENT_ID,
            grant_type: 'authorization_code',
            code: code,
            redirect_uri: REDIRECT_URI,
            code_verifier: codeVerifier,
          }),
        })
        .then(res => res.json())
        .then(data => {
          if (data.access_token) {
            const expiryTime = Date.now() + (data.expires_in * 1000);
            localStorage.setItem('spotify_access_token', data.access_token);
            localStorage.setItem('spotify_token_expiry', expiryTime.toString());
            if (data.refresh_token) {
              localStorage.setItem('spotify_refresh_token', data.refresh_token);
            }
            
            setAccessToken(data.access_token);
            window.history.replaceState({}, document.title, window.location.pathname);
            initializeApp(data.access_token);
          }
        })
        .catch(err => {
          console.error('Error:', err);
          setLoading(false);
        });
      };

      const initializeApp = (token) => {
        setLoading(true);
        
        fetch('https://api.spotify.com/v1/me', {
          headers: { 'Authorization': `Bearer ${token}` }
        })
        .then(res => res.json())
        .then(userData => {
          setUserId(userData.id);
          return Promise.all([
            fetchFollowedArtists(token),
            loadCategoriesFromSpotify(token, userData.id)
          ]);
        })
        .then(() => {
          setLoading(false);
        })
        .catch(err => {
          console.error('Error:', err);
          setLoading(false);
        });
      };

      const loadCategoriesFromSpotify = (token, uid) => {
        return fetch('https://api.spotify.com/v1/me/playlists?limit=50', {
          headers: { 'Authorization': `Bearer ${token}` }
        })
        .then(res => res.json())
        .then(data => {
          const categoryPlaylists = data.items.filter(p => 
            p.name.startsWith(CATEGORY_PREFIX) && p.owner.id === uid
          );
          
          if (categoryPlaylists.length === 0) {
            return { 'Uncategorized': [] };
          }

          const loadedCategories = {};
          
          return Promise.all(
            categoryPlaylists.map(playlist => {
              const categoryName = playlist.name.replace(CATEGORY_PREFIX, '');
              
              return fetch(playlist.tracks.href, {
                headers: { 'Authorization': `Bearer ${token}` }
              })
              .then(res => res.json())
              .then(tracksData => {
                const artistIds = tracksData.items
                  .map(item => item.track?.artists?.[0]?.id)
                  .filter(Boolean);
                loadedCategories[categoryName] = artistIds;
              });
            })
          ).then(() => {
            if (!loadedCategories['Uncategorized']) {
              loadedCategories['Uncategorized'] = [];
            }
            setCategories(loadedCategories);
            return loadedCategories;
          });
        });
      };

      const saveCategoryToSpotify = (token, uid, categoryName, artistIds) => {
        const playlistName = CATEGORY_PREFIX + categoryName;
        
        return fetch('https://api.spotify.com/v1/me/playlists?limit=50', {
          headers: { 'Authorization': `Bearer ${token}` }
        })
        .then(res => res.json())
        .then(data => {
          const existingPlaylist = data.items.find(p => 
            p.name === playlistName && p.owner.id === uid
          );
          
          if (existingPlaylist) {
            return fetch(`https://api.spotify.com/v1/playlists/${existingPlaylist.id}/tracks`, {
              method: 'PUT',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                uris: artistIds.slice(0, 100).map(id => `spotify:artist:${id}`)
              })
            }).then(() => existingPlaylist.id);
          } else {
            return fetch(`https://api.spotify.com/v1/users/${uid}/playlists`, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                name: playlistName,
                description: 'Artist category for organizer app',
                public: false
              })
            })
            .then(res => res.json())
            .then(newPlaylist => {
              if (artistIds.length > 0) {
                return fetch(`https://api.spotify.com/v1/playlists/${newPlaylist.id}/tracks`, {
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    uris: artistIds.slice(0, 100).map(id => `spotify:artist:${id}`)
                  })
                }).then(() => newPlaylist.id);
              }
              return newPlaylist.id;
            });
          }
        });
      };

      const deleteCategoryFromSpotify = (token, uid, categoryName) => {
        const playlistName = CATEGORY_PREFIX + categoryName;
        
        return fetch('https://api.spotify.com/v1/me/playlists?limit=50', {
          headers: { 'Authorization': `Bearer ${token}` }
        })
        .then(res => res.json())
        .then(data => {
          const playlist = data.items.find(p => 
            p.name === playlistName && p.owner.id === uid
          );
          
          if (playlist) {
            return fetch(`https://api.spotify.com/v1/playlists/${playlist.id}/followers`, {
              method: 'DELETE',
              headers: { 'Authorization': `Bearer ${token}` }
            });
          }
        });
      };

      const fetchFollowedArtists = (token) => {
        const fetchPage = (url, accumulated) => {
          return fetch(url, {
            headers: { 'Authorization': `Bearer ${token}` }
          })
          .then(res => {
            if (!res.ok) throw new Error('Failed to fetch');
            return res.json();
          })
          .then(data => {
            const allArtists = accumulated.concat(data.artists.items);
            return data.artists.next ? fetchPage(data.artists.next, allArtists) : allArtists;
          });
        };
        
        return fetchPage('https://api.spotify.com/v1/me/following?type=artist&limit=50', [])
          .then(allArtists => {
            setArtists(allArtists);
            
            const categorizedIds = new Set();
            Object.values(categories).forEach(cat => cat.forEach(id => categorizedIds.add(id)));
            
            const currentArtistIds = new Set(allArtists.map(a => a.id));
            
            const unfollowedIds = new Set();
            Object.entries(categories).forEach(([catName, artistIds]) => {
              artistIds.forEach(id => {
                if (!currentArtistIds.has(id)) {
                  unfollowedIds.add(id);
                }
              });
            });
            
            const uncategorized = allArtists
              .filter(a => !categorizedIds.has(a.id))
              .map(a => a.id);
            
            let updated = { ...categories };
            
            if (unfollowedIds.size > 0) {
              Object.keys(updated).forEach(catName => {
                updated[catName] = updated[catName].filter(id => !unfollowedIds.has(id));
              });
            }
            
            if (uncategorized.length > 0) {
              updated['Uncategorized'] = [...(updated.Uncategorized || []), ...uncategorized];
            }
            
            if (unfollowedIds.size > 0 || uncategorized.length > 0) {
              setCategories(updated);
              if (accessToken && userId) {
                Object.entries(updated).forEach(([catName, artistIds]) => {
                  saveCategoryToSpotify(accessToken, userId, catName, artistIds);
                });
              }
            }
            
            return allArtists;
          });
      };

      const addCategory = () => {
        if (newCategoryName.trim() && !categories[newCategoryName]) {
          const updated = { ...categories, [newCategoryName]: [] };
          setCategories(updated);
          saveCategoryToSpotify(accessToken, userId, newCategoryName, [])
            .then(() => showStatus('âœ“ Category created'))
            .catch(err => showStatus('âœ— Error creating category'));
          setNewCategoryName('');
          setShowNewCategory(false);
        }
      };

      const deleteCategory = (categoryName) => {
        if (categoryName === 'Uncategorized') return;
        const { [categoryName]: deleted, ...rest } = categories;
        const updated = { ...rest, 'Uncategorized': [...rest.Uncategorized, ...deleted] };
        setCategories(updated);
        
        deleteCategoryFromSpotify(accessToken, userId, categoryName)
          .then(() => {
            saveCategoryToSpotify(accessToken, userId, 'Uncategorized', updated['Uncategorized']);
            showStatus('âœ“ Category deleted');
          })
          .catch(err => showStatus('âœ— Error deleting category'));
      };

      const moveArtist = (artistId, fromCategory, toCategory) => {
        const updated = { ...categories };
        updated[fromCategory] = updated[fromCategory].filter(id => id !== artistId);
        updated[toCategory] = [...updated[toCategory], artistId];
        setCategories(updated);
        
        Promise.all([
          saveCategoryToSpotify(accessToken, userId, fromCategory, updated[fromCategory]),
          saveCategoryToSpotify(accessToken, userId, toCategory, updated[toCategory])
        ])
        .then(() => showStatus('âœ“ Artist moved', 1500))
        .catch(err => showStatus('âœ— Error moving artist'));
      };

      const syncWithSpotify = () => {
        if (accessToken && userId) {
          setSyncing(true);
          showStatus('ðŸ”„ Syncing with Spotify...');
          
          Promise.all([
            fetchFollowedArtists(accessToken),
            loadCategoriesFromSpotify(accessToken, userId)
          ])
          .then(() => {
            setSyncing(false);
            showStatus('âœ“ Sync complete!');
          })
          .catch(err => {
            setSyncing(false);
            showStatus('âœ— Sync failed');
          });
        }
      };

      const scrollToCategory = (categoryName) => {
        const element = document.getElementById(`category-${categoryName}`);
        if (element) {
          element.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      };

      const getArtistById = (id) => artists.find(a => a.id === id);

      if (!accessToken) {
        return h('div', { className: 'min-h-screen bg-gradient-to-br from-green-900 via-black to-black flex items-center justify-center p-4' },
          h('div', { className: 'bg-gray-900 rounded-lg p-8 max-w-md w-full text-center shadow-2xl' },
            h('div', { className: 'text-6xl mb-4' }, 'ðŸŽµ'),
            h('h1', { className: 'text-3xl font-bold text-white mb-2' }, 'Spotify Artist Organizer'),
            h('p', { className: 'text-gray-400 mb-6' }, 'Organize your followed artists into custom categories'),
            h('div', { className: 'bg-gray-800 border border-gray-700 rounded p-4 mb-6 text-left text-sm' },
              h('p', { className: 'text-gray-300 mb-2' }, 'Connect your Spotify account to start organizing your followed artists into custom categories.'),
              h('p', { className: 'text-green-400 text-xs font-semibold mb-2' }, 'âœ“ Syncs across all your devices'),
              h('p', { className: 'text-gray-400 text-xs' }, 'Your categories are stored privately in your Spotify account as hidden playlists.')
            ),
            h('button', {
              onClick: handleLogin,
              className: 'bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-6 rounded-full transition'
            }, 'Connect with Spotify')
          )
        );
      }

      if (loading) {
        return h('div', { className: 'min-h-screen bg-gradient-to-br from-green-900 via-black to-black flex items-center justify-center' },
          h('div', { className: 'text-center' },
            h('div', { className: 'text-6xl mb-4 animate-pulse' }, 'ðŸŽµ'),
            h('p', { className: 'text-white' }, 'Loading your artists...')
          )
        );
      }

      return h('div', { className: 'min-h-screen bg-gradient-to-br from-green-900 via-black to-black p-4' },
        h('div', { className: 'max-w-6xl mx-auto' },
          statusMessage && h('div', { className: 'fixed top-4 right-4 bg-gray-900 text-white px-4 py-2 rounded-lg shadow-lg z-50 border border-gray-700' },
            statusMessage
          ),
          h('div', { className: 'flex items-center justify-between mb-6 flex-wrap gap-4' },
            h('div', { className: 'flex items-center gap-3' },
              h('div', { className: 'text-4xl' }, 'ðŸŽµ'),
              h('h1', { className: 'text-2xl font-bold text-white' }, 'My Artist Library'),
              h('span', { className: 'bg-green-500 text-black px-3 py-1 rounded-full text-sm font-semibold' }, `${artists.length} artists`)
            ),
            h('div', { className: 'flex gap-2 flex-wrap' },
              h('select', {
                onChange: (e) => {
                  if (e.target.value) {
                    scrollToCategory(e.target.value);
                    e.target.value = '';
                  }
                },
                className: 'bg-gray-800 text-white px-4 py-2 rounded-full border border-gray-700 cursor-pointer text-sm'
              },
                h('option', { value: '' }, 'ðŸ“‚ Jump to Category...'),
                Object.keys(categories).map(cat => 
                  h('option', { key: cat, value: cat }, `${cat} (${categories[cat].length})`)
                )
              ),
              h('button', {
                onClick: syncWithSpotify,
                disabled: syncing,
                className: 'bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-full text-sm disabled:opacity-50'
              }, syncing ? 'ðŸ”„ Syncing...' : 'ðŸ”„ Sync'),
              h('button', {
                onClick: () => setShowNewCategory(!showNewCategory),
                className: 'bg-green-500 hover:bg-green-600 text-black font-semibold py-2 px-4 rounded-full'
              }, 'âž• New Category')
            )
          ),
          showNewCategory && h('div', { className: 'bg-gray-900 rounded-lg p-4 mb-6 flex flex-col sm:flex-row gap-2' },
            h('input', {
              type: 'text',
              value: newCategoryName,
              onChange: (e) => setNewCategoryName(e.target.value),
              onKeyPress: (e) => e.key === 'Enter' && addCategory(),
              placeholder: 'Category name (e.g., Rock, Jazz, Electronic...)',
              className: 'flex-1 bg-gray-800 text-white px-4 py-2 rounded border border-gray-700 focus:border-green-500 outline-none'
            }),
            h('button', {
              onClick: addCategory,
              className: 'bg-green-500 hover:bg-green-600 text-black font-semibold px-4 py-2 rounded'
            }, 'Add'),
            h('button', {
              onClick: () => setShowNewCategory(false),
              className: 'bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded'
            }, 'Cancel')
          ),
          h('div', { className: 'space-y-6' },
            Object.entries(categories).map(([categoryName, artistIds]) => {
              const categoryArtists = artistIds.map(id => getArtistById(id)).filter(Boolean);
              return h('div', { 
                key: categoryName, 
                id: `category-${categoryName}`,
                className: 'bg-gray-900 rounded-lg p-4 scroll-mt-6'
              },
                h('div', { className: 'flex items-center justify-between mb-4' },
                  h('div', { className: 'flex items-center gap-2' },
                    h('div', { className: 'text-2xl' }, 'ðŸ“'),
                    h('h2', { className: 'text-xl font-bold text-white' }, categoryName),
                    h('span', { className: 'text-gray-400 text-sm' }, `(${categoryArtists.length})`)
                  ),
                  categoryName !== 'Uncategorized' && h('button', {
                    onClick: () => deleteCategory(categoryName),
                    className: 'text-red-400 hover:text-red-300 text-xl'
                  }, 'ðŸ—‘ï¸')
                ),
                categoryArtists.length === 0
                  ? h('p', { className: 'text-gray-500 text-sm italic' }, 'No artists in this category')
                  : h('div', { className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3' },
                      categoryArtists.map(artist =>
                        h('div', { key: artist.id, className: 'bg-gray-800 rounded-lg p-3' },
                          h('img', {
                            src: artist.images[0]?.url || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="100" height="100"%3E%3Crect fill="%23374151" width="100" height="100"/%3E%3C/svg%3E',
                            alt: artist.name,
                            className: 'w-full aspect-square object-cover rounded mb-2'
                          }),
                          h('p', { className: 'text-white font-semibold text-sm mb-1 truncate' }, artist.name),
                          h('a', {
                            href: artist.external_urls.spotify,
                            target: '_blank',
                            rel: 'noopener noreferrer',
                            className: 'block bg-green-500 hover:bg-green-600 text-black text-xs py-1 px-2 rounded text-center mb-2'
                          }, 'ðŸ”— Open in Spotify'),
                          h('select', {
                            value: categoryName,
                            onChange: (e) => moveArtist(artist.id, categoryName, e.target.value),
                            className: 'w-full bg-gray-700 text-white text-xs py-1 px-2 rounded border border-gray-600 outline-none'
                          }, Object.keys(categories).map(cat => h('option', { key: cat, value: cat }, cat)))
                        )
                      )
                    )
              );
            })
          )
        )
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(SpotifyOrganizer));
  </script>
</body>
</html>
