<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spotify Artist Organizer</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, sans-serif; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script>
    const { useState, useEffect, createElement: h } = React;

    function generateRandomString(length) {
      const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      const values = crypto.getRandomValues(new Uint8Array(length));
      let result = '';
      for (let i = 0; i < length; i++) {
        result += possible[values[i] % possible.length];
      }
      return result;
    }

    function sha256(plain) {
      const encoder = new TextEncoder();
      const data = encoder.encode(plain);
      return window.crypto.subtle.digest('SHA-256', data);
    }

    function base64encode(input) {
      return btoa(String.fromCharCode.apply(null, new Uint8Array(input)))
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
    }

    const SpotifyOrganizer = () => {
      const [accessToken, setAccessToken] = useState(null);
      const [userId, setUserId] = useState(null);
      const [artists, setArtists] = useState([]);
      const [categories, setCategories] = useState({});
      const [categoryPlaylists, setCategoryPlaylists] = useState({}); // Maps category name to playlist ID
      const [loading, setLoading] = useState(false);
      const [newCategoryName, setNewCategoryName] = useState('');
      const [showNewCategory, setShowNewCategory] = useState(false);
      const [syncing, setSyncing] = useState(false);
      const [statusMessage, setStatusMessage] = useState('');

      const CLIENT_ID = 'e21bf88870a94703bc0cdcf317075a5e';
      const REDIRECT_URI = 'https://albocanegra.github.io/spotify-organizer';
      const SCOPES = 'user-follow-read playlist-read-private playlist-modify-private playlist-modify-public';
      
      // Playlist naming convention
      const PLAYLIST_PREFIX = 'ðŸŽ¸ ';
      const APP_VERSION = 'v3.0.0';

      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const code = params.get('code');
        
        if (code) {
          exchangeCodeForToken(code);
        }

        const token = localStorage.getItem('spotify_access_token');
        const expiry = localStorage.getItem('spotify_token_expiry');
        
        if (token && expiry && Date.now() < parseInt(expiry)) {
          setAccessToken(token);
          initializeApp(token);
        }
      }, []);

      const showStatus = (message, duration = 3000) => {
        setStatusMessage(message);
        setTimeout(() => setStatusMessage(''), duration);
      };

      const handleLogin = () => {
        const codeVerifier = generateRandomString(64);
        sha256(codeVerifier).then((hashed) => {
          const codeChallenge = base64encode(hashed);
          localStorage.setItem('code_verifier', codeVerifier);

          const authUrl = new URL('https://accounts.spotify.com/authorize');
          const params = {
            client_id: CLIENT_ID,
            response_type: 'code',
            redirect_uri: REDIRECT_URI,
            scope: SCOPES,
            code_challenge_method: 'S256',
            code_challenge: codeChallenge,
          };

          authUrl.search = new URLSearchParams(params).toString();
          window.location.href = authUrl.toString();
        });
      };

      const exchangeCodeForToken = (code) => {
        setLoading(true);
        const codeVerifier = localStorage.getItem('code_verifier');

        fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            client_id: CLIENT_ID,
            grant_type: 'authorization_code',
            code: code,
            redirect_uri: REDIRECT_URI,
            code_verifier: codeVerifier,
          }),
        })
        .then(res => res.json())
        .then(data => {
          if (data.access_token) {
            const expiryTime = Date.now() + (data.expires_in * 1000);
            localStorage.setItem('spotify_access_token', data.access_token);
            localStorage.setItem('spotify_token_expiry', expiryTime.toString());
            if (data.refresh_token) {
              localStorage.setItem('spotify_refresh_token', data.refresh_token);
            }
            
            setAccessToken(data.access_token);
            window.history.replaceState({}, document.title, window.location.pathname);
            initializeApp(data.access_token);
          }
        })
        .catch(err => {
          console.error('Error:', err);
          setLoading(false);
        });
      };

      const initializeApp = (token) => {
        setLoading(true);
        
        fetch('https://api.spotify.com/v1/me', {
          headers: { 'Authorization': `Bearer ${token}` }
        })
        .then(res => res.json())
        .then(userData => {
          setUserId(userData.id);
          // Load categories from playlists first, then fetch artists
          return loadCategoriesFromPlaylists(token, userData.id)
            .then(({ loadedCategories, playlists }) => {
              return fetchFollowedArtists(token).then(allArtists => ({
                loadedCategories,
                playlists,
                allArtists
              }));
            })
            .then(({ loadedCategories, playlists, allArtists }) => {
              // Find uncategorized artists
              const categorizedIds = new Set();
              Object.values(loadedCategories).forEach(ids => ids.forEach(id => categorizedIds.add(id)));
              
              const uncategorizedArtists = allArtists.filter(a => !categorizedIds.has(a.id));
              
              if (uncategorizedArtists.length > 0) {
                // Ensure Uncategorized playlist exists and add artists
                return ensureUncategorizedPlaylist(token, userData.id, playlists)
                  .then(uncatPlaylistId => {
                    const updatedPlaylists = { ...playlists };
                    if (!updatedPlaylists['Uncategorized']) {
                      updatedPlaylists['Uncategorized'] = uncatPlaylistId;
                    }
                    
                    // Add uncategorized artists to the playlist
                    return addArtistsToPlaylist(token, uncatPlaylistId, uncategorizedArtists)
                      .then(() => {
                        const updatedCategories = { ...loadedCategories };
                        updatedCategories['Uncategorized'] = [
                          ...(updatedCategories['Uncategorized'] || []),
                          ...uncategorizedArtists.map(a => a.id)
                        ];
                        setCategories(updatedCategories);
                        setCategoryPlaylists(updatedPlaylists);
                      });
                  });
              } else {
                setCategories(loadedCategories);
                setCategoryPlaylists(playlists);
              }
            });
        })
        .then(() => {
          setLoading(false);
        })
        .catch(err => {
          console.error('Error:', err);
          setLoading(false);
        });
      };

      const ensureUncategorizedPlaylist = (token, uid, existingPlaylists) => {
        if (existingPlaylists['Uncategorized']) {
          return Promise.resolve(existingPlaylists['Uncategorized']);
        }
        
        return fetch(`https://api.spotify.com/v1/users/${uid}/playlists`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: `${PLAYLIST_PREFIX}Uncategorized`,
            description: 'Artists not yet categorized - managed by Artist Organizer',
            public: false
          })
        })
        .then(res => res.json())
        .then(playlist => playlist.id);
      };

      const loadCategoriesFromPlaylists = (token, uid) => {
        // Fetch all user playlists (paginated)
        const fetchAllPlaylists = (url, accumulated) => {
          return fetch(url, {
            headers: { 'Authorization': `Bearer ${token}` }
          })
          .then(res => res.json())
          .then(data => {
            const all = accumulated.concat(data.items || []);
            return data.next ? fetchAllPlaylists(data.next, all) : all;
          });
        };

        return fetchAllPlaylists('https://api.spotify.com/v1/me/playlists?limit=50', [])
          .then(allPlaylists => {
            // Filter to only our category playlists
            const categoryPlaylists = allPlaylists.filter(p => 
              p && p.name && p.name.startsWith(PLAYLIST_PREFIX) && p.owner.id === uid
            );
            
            if (categoryPlaylists.length === 0) {
              return { loadedCategories: {}, playlists: {} };
            }

            // For each category playlist, fetch its tracks and map to artists
            const categoryPromises = categoryPlaylists.map(playlist => {
              const categoryName = playlist.name.substring(PLAYLIST_PREFIX.length);
              
              return fetchPlaylistTracks(token, playlist.id)
                .then(tracks => {
                  // Extract unique artist IDs from tracks
                  const artistIds = [...new Set(
                    tracks
                      .filter(t => t.track && t.track.artists && t.track.artists[0])
                      .map(t => t.track.artists[0].id)
                  )];
                  
                  return {
                    categoryName,
                    playlistId: playlist.id,
                    artistIds
                  };
                });
            });

            return Promise.all(categoryPromises).then(results => {
              const loadedCategories = {};
              const playlists = {};
              
              results.forEach(({ categoryName, playlistId, artistIds }) => {
                loadedCategories[categoryName] = artistIds;
                playlists[categoryName] = playlistId;
              });
              
              return { loadedCategories, playlists };
            });
          });
      };

      const fetchPlaylistTracks = (token, playlistId) => {
        const fetchPage = (url, accumulated) => {
          return fetch(url, {
            headers: { 'Authorization': `Bearer ${token}` }
          })
          .then(res => res.json())
          .then(data => {
            const all = accumulated.concat(data.items || []);
            return data.next ? fetchPage(data.next, all) : all;
          });
        };

        return fetchPage(`https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100`, []);
      };

      const fetchFollowedArtists = (token) => {
        const fetchPage = (url, accumulated) => {
          return fetch(url, {
            headers: { 'Authorization': `Bearer ${token}` }
          })
          .then(res => {
            if (!res.ok) throw new Error('Failed to fetch');
            return res.json();
          })
          .then(data => {
            const allArtists = accumulated.concat(data.artists.items);
            return data.artists.next ? fetchPage(data.artists.next, allArtists) : allArtists;
          });
        };
        
        return fetchPage('https://api.spotify.com/v1/me/following?type=artist&limit=50', [])
          .then(allArtists => {
            setArtists(allArtists);
            return allArtists;
          });
      };

      const getArtistTopTrack = (token, artistId) => {
        return fetch(`https://api.spotify.com/v1/artists/${artistId}/top-tracks?market=US`, {
          headers: { 'Authorization': `Bearer ${token}` }
        })
        .then(res => res.json())
        .then(data => {
          if (data.tracks && data.tracks.length > 0) {
            return data.tracks[0].uri;
          }
          return null;
        });
      };

      const addArtistsToPlaylist = (token, playlistId, artistsToAdd) => {
        // Get top tracks for all artists and add them
        const trackPromises = artistsToAdd.map(artist => 
          getArtistTopTrack(token, artist.id)
        );

        return Promise.all(trackPromises)
          .then(trackUris => {
            const validUris = trackUris.filter(uri => uri !== null);
            if (validUris.length === 0) return Promise.resolve();

            // Spotify allows max 100 tracks per request
            const batches = [];
            for (let i = 0; i < validUris.length; i += 100) {
              batches.push(validUris.slice(i, i + 100));
            }

            return batches.reduce((promise, batch) => {
              return promise.then(() => 
                fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, {
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({ uris: batch })
                })
              );
            }, Promise.resolve());
          });
      };

      const addCategory = () => {
        if (!newCategoryName.trim() || categories[newCategoryName]) return;
        
        const categoryName = newCategoryName.trim();
        showStatus('Creating category...');
        
        // Create a new playlist for this category
        fetch(`https://api.spotify.com/v1/users/${userId}/playlists`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: `${PLAYLIST_PREFIX}${categoryName}`,
            description: `Artists categorized as "${categoryName}" - managed by Artist Organizer`,
            public: false
          })
        })
        .then(res => res.json())
        .then(playlist => {
          setCategories(prev => ({ ...prev, [categoryName]: [] }));
          setCategoryPlaylists(prev => ({ ...prev, [categoryName]: playlist.id }));
          setNewCategoryName('');
          setShowNewCategory(false);
          showStatus('âœ“ Category created');
        })
        .catch(err => {
          console.error('Error creating category:', err);
          showStatus('âœ— Error creating category');
        });
      };

      const deleteCategory = (categoryName) => {
        if (categoryName === 'Uncategorized') return;
        
        const playlistId = categoryPlaylists[categoryName];
        const artistsToMove = categories[categoryName] || [];
        
        showStatus('Deleting category...');
        
        // Move artists to Uncategorized first
        const movePromise = artistsToMove.length > 0 
          ? addArtistsToPlaylist(
              accessToken, 
              categoryPlaylists['Uncategorized'], 
              artistsToMove.map(id => artists.find(a => a.id === id)).filter(Boolean)
            )
          : Promise.resolve();

        movePromise
          .then(() => {
            // Unfollow (delete) the playlist
            return fetch(`https://api.spotify.com/v1/playlists/${playlistId}/followers`, {
              method: 'DELETE',
              headers: { 'Authorization': `Bearer ${accessToken}` }
            });
          })
          .then(() => {
            setCategories(prev => {
              const { [categoryName]: deleted, ...rest } = prev;
              return {
                ...rest,
                'Uncategorized': [...(rest['Uncategorized'] || []), ...artistsToMove]
              };
            });
            setCategoryPlaylists(prev => {
              const { [categoryName]: deleted, ...rest } = prev;
              return rest;
            });
            showStatus('âœ“ Category deleted');
          })
          .catch(err => {
            console.error('Error deleting category:', err);
            showStatus('âœ— Error deleting category');
          });
      };

      const removeArtistTracksFromPlaylist = (token, playlistId, artistId) => {
        // First get all tracks in the playlist
        return fetchPlaylistTracks(token, playlistId)
          .then(tracks => {
            // Find tracks by this artist
            const tracksToRemove = tracks
              .filter(t => t.track && t.track.artists && t.track.artists[0] && t.track.artists[0].id === artistId)
              .map(t => ({ uri: t.track.uri }));
            
            if (tracksToRemove.length === 0) return Promise.resolve();

            return fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, {
              method: 'DELETE',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ tracks: tracksToRemove })
            });
          });
      };

      const moveArtist = (artistId, fromCategory, toCategory) => {
        if (fromCategory === toCategory) return;
        
        const artist = artists.find(a => a.id === artistId);
        if (!artist) return;

        showStatus('Moving artist...', 1500);

        const fromPlaylistId = categoryPlaylists[fromCategory];
        const toPlaylistId = categoryPlaylists[toCategory];

        // Remove from old playlist, add to new one
        removeArtistTracksFromPlaylist(accessToken, fromPlaylistId, artistId)
          .then(() => addArtistsToPlaylist(accessToken, toPlaylistId, [artist]))
          .then(() => {
            setCategories(prev => {
              const updated = { ...prev };
              updated[fromCategory] = updated[fromCategory].filter(id => id !== artistId);
              updated[toCategory] = [...(updated[toCategory] || []), artistId];
              return updated;
            });
            showStatus('âœ“ Artist moved', 1500);
          })
          .catch(err => {
            console.error('Error moving artist:', err);
            showStatus('âœ— Error moving artist');
          });
      };

      const syncWithSpotify = () => {
        if (accessToken && userId) {
          setSyncing(true);
          showStatus('ðŸ”„ Syncing with Spotify...');
          
          loadCategoriesFromPlaylists(accessToken, userId)
            .then(({ loadedCategories, playlists }) => {
              return fetchFollowedArtists(accessToken).then(allArtists => ({
                loadedCategories,
                playlists,
                allArtists
              }));
            })
            .then(({ loadedCategories, playlists, allArtists }) => {
              // Find uncategorized artists (followed but not in any category)
              const categorizedIds = new Set();
              Object.values(loadedCategories).forEach(ids => ids.forEach(id => categorizedIds.add(id)));
              
              const uncategorizedArtists = allArtists.filter(a => !categorizedIds.has(a.id));
              
              // Remove unfollowed artists from categories
              const currentArtistIds = new Set(allArtists.map(a => a.id));
              Object.keys(loadedCategories).forEach(cat => {
                loadedCategories[cat] = loadedCategories[cat].filter(id => currentArtistIds.has(id));
              });
              
              if (uncategorizedArtists.length > 0) {
                return ensureUncategorizedPlaylist(accessToken, userId, playlists)
                  .then(uncatPlaylistId => {
                    const updatedPlaylists = { ...playlists };
                    if (!updatedPlaylists['Uncategorized']) {
                      updatedPlaylists['Uncategorized'] = uncatPlaylistId;
                    }
                    
                    return addArtistsToPlaylist(accessToken, uncatPlaylistId, uncategorizedArtists)
                      .then(() => {
                        loadedCategories['Uncategorized'] = [
                          ...(loadedCategories['Uncategorized'] || []),
                          ...uncategorizedArtists.map(a => a.id)
                        ];
                        setCategories(loadedCategories);
                        setCategoryPlaylists(updatedPlaylists);
                      });
                  });
              } else {
                setCategories(loadedCategories);
                setCategoryPlaylists(playlists);
              }
            })
            .then(() => {
              setSyncing(false);
              showStatus('âœ“ Sync complete!');
            })
            .catch(err => {
              console.error('Sync error:', err);
              setSyncing(false);
              showStatus('âœ— Sync failed');
            });
        }
      };

      const scrollToCategory = (categoryName) => {
        const element = document.getElementById(`category-${categoryName}`);
        if (element) {
          element.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      };

      const getArtistById = (id) => artists.find(a => a.id === id);

      if (!accessToken) {
        return h('div', { className: 'min-h-screen bg-gradient-to-br from-green-900 via-black to-black flex items-center justify-center p-4' },
          h('div', { className: 'bg-gray-900 rounded-lg p-8 max-w-md w-full text-center shadow-2xl' },
            h('div', { className: 'text-6xl mb-4' }, 'ðŸŽ¸'),
            h('h1', { className: 'text-3xl font-bold text-white mb-2' }, 'Spotify Artist Organizer'),
            h('p', { className: 'text-gray-400 mb-6' }, 'Organize your followed artists into custom categories'),
            h('div', { className: 'bg-gray-800 border border-gray-700 rounded p-4 mb-6 text-left text-sm' },
              h('p', { className: 'text-gray-300 mb-2' }, 'Connect your Spotify account to start organizing your followed artists into custom categories.'),
              h('p', { className: 'text-green-400 text-xs font-semibold mb-2' }, 'âœ“ Categories saved as playlists in your Spotify'),
              h('p', { className: 'text-green-400 text-xs font-semibold mb-2' }, 'âœ“ Syncs across all your devices'),
              h('p', { className: 'text-gray-400 text-xs mb-2' }, 'Each category becomes a playlist with tracks from your categorized artists.'),
              h('p', { className: 'text-gray-500 text-xs text-right' }, APP_VERSION)
            ),
            h('button', {
              onClick: handleLogin,
              className: 'bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-6 rounded-full transition'
            }, 'Connect with Spotify')
          )
        );
      }

      if (loading) {
        return h('div', { className: 'min-h-screen bg-gradient-to-br from-green-900 via-black to-black flex items-center justify-center' },
          h('div', { className: 'text-center' },
            h('div', { className: 'text-6xl mb-4 animate-pulse' }, 'ðŸŽ¸'),
            h('p', { className: 'text-white' }, 'Loading your artists...')
          )
        );
      }

      const categoryEntries = Object.entries(categories);
      // Sort so Uncategorized is always last
      categoryEntries.sort((a, b) => {
        if (a[0] === 'Uncategorized') return 1;
        if (b[0] === 'Uncategorized') return -1;
        return a[0].localeCompare(b[0]);
      });

      return h('div', { className: 'min-h-screen bg-gradient-to-br from-green-900 via-black to-black p-4' },
        h('div', { className: 'max-w-6xl mx-auto' },
          statusMessage && h('div', { className: 'fixed top-4 right-4 bg-gray-900 text-white px-4 py-2 rounded-lg shadow-lg z-50 border border-gray-700' },
            statusMessage
          ),
          h('div', { className: 'flex items-center justify-between mb-6 flex-wrap gap-4' },
            h('div', { className: 'flex items-center gap-3' },
              h('div', { className: 'text-4xl' }, 'ðŸŽ¸'),
              h('h1', { className: 'text-2xl font-bold text-white' }, 'My Artist Library'),
              h('span', { className: 'bg-green-500 text-black px-3 py-1 rounded-full text-sm font-semibold' }, `${artists.length} artists`),
              h('span', { className: 'bg-gray-800 text-gray-400 px-2 py-1 rounded text-xs' }, APP_VERSION)
            ),
            h('div', { className: 'flex gap-2 flex-wrap' },
              h('select', {
                onChange: (e) => {
                  if (e.target.value) {
                    scrollToCategory(e.target.value);
                    e.target.value = '';
                  }
                },
                className: 'bg-gray-800 text-white px-4 py-2 rounded-full border border-gray-700 cursor-pointer text-sm'
              },
                h('option', { value: '' }, 'ðŸ“‚ Jump to Category...'),
                categoryEntries.map(([cat, artistIds]) => 
                  h('option', { key: cat, value: cat }, `${cat} (${artistIds.length})`)
                )
              ),
              h('button', {
                onClick: syncWithSpotify,
                disabled: syncing,
                className: 'bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-full text-sm disabled:opacity-50'
              }, syncing ? 'ðŸ”„ Syncing...' : 'ðŸ”„ Sync'),
              h('button', {
                onClick: () => setShowNewCategory(!showNewCategory),
                className: 'bg-green-500 hover:bg-green-600 text-black font-semibold py-2 px-4 rounded-full'
              }, 'âž• New Category')
            )
          ),
          showNewCategory && h('div', { className: 'bg-gray-900 rounded-lg p-4 mb-6 flex flex-col sm:flex-row gap-2' },
            h('input', {
              type: 'text',
              value: newCategoryName,
              onChange: (e) => setNewCategoryName(e.target.value),
              onKeyPress: (e) => e.key === 'Enter' && addCategory(),
              placeholder: 'Category name (e.g., Rock, Jazz, Electronic...)',
              className: 'flex-1 bg-gray-800 text-white px-4 py-2 rounded border border-gray-700 focus:border-green-500 outline-none'
            }),
            h('button', {
              onClick: addCategory,
              className: 'bg-green-500 hover:bg-green-600 text-black font-semibold px-4 py-2 rounded'
            }, 'Add'),
            h('button', {
              onClick: () => setShowNewCategory(false),
              className: 'bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded'
            }, 'Cancel')
          ),
          categoryEntries.length === 0 
            ? h('div', { className: 'bg-gray-900 rounded-lg p-8 text-center' },
                h('p', { className: 'text-gray-400 mb-4' }, 'No categories yet. Create your first category to start organizing!'),
                h('button', {
                  onClick: () => setShowNewCategory(true),
                  className: 'bg-green-500 hover:bg-green-600 text-black font-semibold py-2 px-4 rounded-full'
                }, 'âž• Create First Category')
              )
            : h('div', { className: 'space-y-6' },
                categoryEntries.map(([categoryName, artistIds]) => {
                  const categoryArtists = artistIds.map(id => getArtistById(id)).filter(Boolean);
                  return h('div', { 
                    key: categoryName, 
                    id: `category-${categoryName}`,
                    className: 'bg-gray-900 rounded-lg p-4 scroll-mt-6'
                  },
                    h('div', { className: 'flex items-center justify-between mb-4' },
                      h('div', { className: 'flex items-center gap-2' },
                        h('div', { className: 'text-2xl' }, categoryName === 'Uncategorized' ? 'ðŸ“¥' : 'ðŸ“'),
                        h('h2', { className: 'text-xl font-bold text-white' }, categoryName),
                        h('span', { className: 'text-gray-400 text-sm' }, `(${categoryArtists.length})`),
                        categoryPlaylists[categoryName] && h('a', {
                          href: `https://open.spotify.com/playlist/${categoryPlaylists[categoryName]}`,
                          target: '_blank',
                          rel: 'noopener noreferrer',
                          className: 'text-green-400 hover:text-green-300 text-xs ml-2'
                        }, 'â†— Open Playlist')
                      ),
                      categoryName !== 'Uncategorized' && h('button', {
                        onClick: () => deleteCategory(categoryName),
                        className: 'text-red-400 hover:text-red-300 text-xl'
                      }, 'ðŸ—‘ï¸')
                    ),
                    categoryArtists.length === 0
                      ? h('p', { className: 'text-gray-500 text-sm italic' }, 'No artists in this category')
                      : h('div', { className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3' },
                          categoryArtists.map(artist =>
                            h('div', { key: artist.id, className: 'bg-gray-800 rounded-lg p-3' },
                              h('img', {
                                src: artist.images[0]?.url || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="100" height="100"%3E%3Crect fill="%23374151" width="100" height="100"/%3E%3C/svg%3E',
                                alt: artist.name,
                                className: 'w-full aspect-square object-cover rounded mb-2'
                              }),
                              h('p', { className: 'text-white font-semibold text-sm mb-1 truncate' }, artist.name),
                              h('a', {
                                href: artist.external_urls.spotify,
                                target: '_blank',
                                rel: 'noopener noreferrer',
                                className: 'block bg-green-500 hover:bg-green-600 text-black text-xs py-1 px-2 rounded text-center mb-2'
                              }, 'ðŸ”— Open in Spotify'),
                              h('select', {
                                value: categoryName,
                                onChange: (e) => moveArtist(artist.id, categoryName, e.target.value),
                                className: 'w-full bg-gray-700 text-white text-xs py-1 px-2 rounded border border-gray-600 outline-none'
                              }, categoryEntries.map(([cat]) => h('option', { key: cat, value: cat }, cat)))
                            )
                          )
                        )
                  );
                })
              )
        )
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(SpotifyOrganizer));
  </script>
</body>
</html>
