<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spotify Artist Organizer</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, sans-serif; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script>
    const { useState, useEffect, createElement: h } = React;

    // PKCE helper functions
    function generateRandomString(length) {
      const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      const values = crypto.getRandomValues(new Uint8Array(length));
      return values.reduce(function(acc, x) { return acc + possible[x % possible.length]; }, "");
    }

    function sha256(plain) {
      const encoder = new TextEncoder();
      const data = encoder.encode(plain);
      return window.crypto.subtle.digest('SHA-256', data);
    }

    function base64encode(input) {
      return btoa(String.fromCharCode.apply(null, new Uint8Array(input)))
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
    }

    const SpotifyOrganizer = () => {
      const [accessToken, setAccessToken] = useState(null);
      const [artists, setArtists] = useState([]);
      const [categories, setCategories] = useState({ 'Uncategorized': [] });
      const [loading, setLoading] = useState(false);
      const [newCategoryName, setNewCategoryName] = useState('');
      const [showNewCategory, setShowNewCategory] = useState(false);
      const [syncing, setSyncing] = useState(false);

      const CLIENT_ID = 'e21bf88870a94703bc0cdcf317075a5e';
      const REDIRECT_URI = 'https://albocanegra.github.io/spotify-organizer';
      const SCOPES = 'user-follow-read';

      useEffect(() => {
        // Check if we're returning from Spotify auth
        const params = new URLSearchParams(window.location.search);
        const code = params.get('code');
        
        if (code) {
          exchangeCodeForToken(code);
        }

        // Load saved categories
        const saved = localStorage.getItem('spotifyCategories');
        if (saved) setCategories(JSON.parse(saved));

        // Check if we have a valid token
        const token = localStorage.getItem('spotify_access_token');
        const expiry = localStorage.getItem('spotify_token_expiry');
        
        if (token && expiry && Date.now() < parseInt(expiry)) {
          setAccessToken(token);
          fetchFollowedArtists(token);
        }
      }, []);

      const handleLogin = function() {
        const codeVerifier = generateRandomString(64);
        sha256(codeVerifier).then(function(hashed) {
          const codeChallenge = base64encode(hashed);

          localStorage.setItem('code_verifier', codeVerifier);

          const authUrl = new URL('https://accounts.spotify.com/authorize');
          const params = {
            client_id: CLIENT_ID,
            response_type: 'code',
            redirect_uri: REDIRECT_URI,
            scope: SCOPES,
            code_challenge_method: 'S256',
            code_challenge: codeChallenge,
          };

          authUrl.search = new URLSearchParams(params).toString();
          window.location.href = authUrl.toString();
        });
      };

      const exchangeCodeForToken = function(code) {
        setLoading(true);
        const codeVerifier = localStorage.getItem('code_verifier');

        fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: new URLSearchParams({
            client_id: CLIENT_ID,
            grant_type: 'authorization_code',
            code: code,
            redirect_uri: REDIRECT_URI,
            code_verifier: codeVerifier,
          }),
        })
        .then(function(response) { return response.json(); })
        .then(function(data) {
          if (data.access_token) {
            const expiryTime = Date.now() + (data.expires_in * 1000);
            localStorage.setItem('spotify_access_token', data.access_token);
            localStorage.setItem('spotify_token_expiry', expiryTime.toString());
            if (data.refresh_token) {
              localStorage.setItem('spotify_refresh_token', data.refresh_token);
            }
            
            setAccessToken(data.access_token);
            window.history.replaceState({}, document.title, window.location.pathname);
            fetchFollowedArtists(data.access_token);
          }
        })
        .catch(function(error) {
          console.error('Error exchanging code for token:', error);
          setLoading(false);
        });
      };

      const fetchFollowedArtists = function(token) {
        setLoading(true);
        
        function fetchPage(url, accumulated) {
          return fetch(url, {
            headers: { 'Authorization': 'Bearer ' + token }
          })
          .then(function(response) {
            if (!response.ok) {
              throw new Error('Failed to fetch artists');
            }
            return response.json();
          })
          .then(function(data) {
            const allArtists = accumulated.concat(data.artists.items);
            
            if (data.artists.next) {
              return fetchPage(data.artists.next, allArtists);
            } else {
              return allArtists;
            }
          });
        }
        
        fetchPage('https://api.spotify.com/v1/me/following?type=artist&limit=50', [])
          .then(function(allArtists) {
            setArtists(allArtists);
            
            const categorizedIds = new Set();
            Object.values(categories).forEach(function(cat) {
              cat.forEach(function(id) { categorizedIds.add(id); });
            });
            
            const uncategorized = allArtists.filter(function(a) { 
              return !categorizedIds.has(a.id); 
            }).map(function(a) { return a.id; });
            
            if (uncategorized.length > 0) {
              const updated = Object.assign({}, categories, {
                'Uncategorized': (categories.Uncategorized || []).concat(uncategorized)
              });
              setCategories(updated);
              localStorage.setItem('spotifyCategories', JSON.stringify(updated));
            }
            setLoading(false);
          })
          .catch(function(error) {
            console.error('Error:', error);
            setLoading(false);
          });
      };

      const addCategory = () => {
        if (newCategoryName.trim() && !categories[newCategoryName]) {
          const updated = { ...categories, [newCategoryName]: [] };
          setCategories(updated);
          localStorage.setItem('spotifyCategories', JSON.stringify(updated));
          setNewCategoryName('');
          setShowNewCategory(false);
        }
      };

      const deleteCategory = (categoryName) => {
        if (categoryName === 'Uncategorized') return;
        const { [categoryName]: deleted, ...rest } = categories;
        const updated = { ...rest, 'Uncategorized': [...rest.Uncategorized, ...deleted] };
        setCategories(updated);
        localStorage.setItem('spotifyCategories', JSON.stringify(updated));
      };

      const moveArtist = (artistId, fromCategory, toCategory) => {
        const updated = { ...categories };
        updated[fromCategory] = updated[fromCategory].filter(id => id !== artistId);
        updated[toCategory] = [...updated[toCategory], artistId];
        setCategories(updated);
        localStorage.setItem('spotifyCategories', JSON.stringify(updated));
      };

      const syncWithSpotify = () => {
        if (accessToken) {
          setSyncing(true);
          fetchFollowedArtists(accessToken);
          setTimeout(() => setSyncing(false), 1000);
        }
      };

      const scrollToCategory = (categoryName) => {
        const element = document.getElementById(`category-${categoryName}`);
        if (element) {
          element.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      };

      const getArtistById = (id) => artists.find(a => a.id === id);

      if (!accessToken) {
        return h('div', { className: 'min-h-screen bg-gradient-to-br from-green-900 via-black to-black flex items-center justify-center p-4' },
          h('div', { className: 'bg-gray-900 rounded-lg p-8 max-w-md w-full text-center shadow-2xl' },
            h('div', { className: 'text-6xl mb-4' }, 'ðŸŽµ'),
            h('h1', { className: 'text-3xl font-bold text-white mb-2' }, 'Spotify Artist Organizer'),
            h('p', { className: 'text-gray-400 mb-6' }, 'Organize your followed artists into custom categories'),
            h('div', { className: 'bg-gray-800 border border-gray-700 rounded p-4 mb-6 text-left text-sm' },
              h('p', { className: 'text-gray-300 mb-2' }, 'Connect your Spotify account to start organizing your followed artists into custom categories.'),
              h('p', { className: 'text-gray-400 text-xs' }, 'Your data is stored locally in your browser.')
            ),
            h('button', {
              onClick: handleLogin,
              className: 'bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-6 rounded-full transition'
            }, 'Connect with Spotify')
          )
        );
      }

      if (loading) {
        return h('div', { className: 'min-h-screen bg-gradient-to-br from-green-900 via-black to-black flex items-center justify-center' },
          h('div', { className: 'text-center' },
            h('div', { className: 'text-6xl mb-4 animate-pulse' }, 'ðŸŽµ'),
            h('p', { className: 'text-white' }, 'Loading your artists...')
          )
        );
      }

      return h('div', { className: 'min-h-screen bg-gradient-to-br from-green-900 via-black to-black p-4' },
        h('div', { className: 'max-w-6xl mx-auto' },
          h('div', { className: 'flex items-center justify-between mb-6 flex-wrap gap-4' },
            h('div', { className: 'flex items-center gap-3' },
              h('div', { className: 'text-4xl' }, 'ðŸŽµ'),
              h('h1', { className: 'text-2xl font-bold text-white' }, 'My Artist Library'),
              h('span', { className: 'bg-green-500 text-black px-3 py-1 rounded-full text-sm font-semibold' }, `${artists.length} artists`)
            ),
            h('div', { className: 'flex gap-2 flex-wrap' },
              h('select', {
                onChange: (e) => {
                  if (e.target.value) {
                    scrollToCategory(e.target.value);
                    e.target.value = '';
                  }
                },
                className: 'bg-gray-800 text-white px-4 py-2 rounded-full border border-gray-700 cursor-pointer text-sm'
              },
                h('option', { value: '' }, 'ðŸ“‚ Jump to Category...'),
                Object.keys(categories).map(cat => 
                  h('option', { key: cat, value: cat }, `${cat} (${categories[cat].length})`)
                )
              ),
              h('button', {
                onClick: syncWithSpotify,
                disabled: syncing,
                className: 'bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-full text-sm disabled:opacity-50'
              }, syncing ? 'ðŸ”„ Syncing...' : 'ðŸ”„ Sync'),
              h('button', {
                onClick: () => setShowNewCategory(!showNewCategory),
                className: 'bg-green-500 hover:bg-green-600 text-black font-semibold py-2 px-4 rounded-full'
              }, 'âž• New Category')
            )
          ),
          showNewCategory && h('div', { className: 'bg-gray-900 rounded-lg p-4 mb-6 flex flex-col sm:flex-row gap-2' },
            h('input', {
              type: 'text',
              value: newCategoryName,
              onChange: (e) => setNewCategoryName(e.target.value),
              onKeyPress: (e) => e.key === 'Enter' && addCategory(),
              placeholder: 'Category name (e.g., Rock, Jazz, Electronic...)',
              className: 'flex-1 bg-gray-800 text-white px-4 py-2 rounded border border-gray-700 focus:border-green-500 outline-none'
            }),
            h('button', {
              onClick: addCategory,
              className: 'bg-green-500 hover:bg-green-600 text-black font-semibold px-4 py-2 rounded'
            }, 'Add'),
            h('button', {
              onClick: () => setShowNewCategory(false),
              className: 'bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded'
            }, 'Cancel')
          ),
          h('div', { className: 'space-y-6' },
            Object.entries(categories).map(([categoryName, artistIds]) => {
              const categoryArtists = artistIds.map(id => getArtistById(id)).filter(Boolean);
              return h('div', { 
                key: categoryName, 
                id: `category-${categoryName}`,
                className: 'bg-gray-900 rounded-lg p-4 scroll-mt-6'
              },
                h('div', { className: 'flex items-center justify-between mb-4' },
                  h('div', { className: 'flex items-center gap-2' },
                    h('div', { className: 'text-2xl' }, 'ðŸ“'),
                    h('h2', { className: 'text-xl font-bold text-white' }, categoryName),
                    h('span', { className: 'text-gray-400 text-sm' }, `(${categoryArtists.length})`)
                  ),
                  categoryName !== 'Uncategorized' && h('button', {
                    onClick: () => deleteCategory(categoryName),
                    className: 'text-red-400 hover:text-red-300 text-xl'
                  }, 'ðŸ—‘ï¸')
                ),
                categoryArtists.length === 0
                  ? h('p', { className: 'text-gray-500 text-sm italic' }, 'No artists in this category')
                  : h('div', { className: 'grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3' },
                      categoryArtists.map(artist =>
                        h('div', { key: artist.id, className: 'bg-gray-800 rounded-lg p-3' },
                          h('img', {
                            src: artist.images[0]?.url || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="100" height="100"%3E%3Crect fill="%23374151" width="100" height="100"/%3E%3C/svg%3E',
                            alt: artist.name,
                            className: 'w-full aspect-square object-cover rounded mb-2'
                          }),
                          h('p', { className: 'text-white font-semibold text-sm mb-1 truncate' }, artist.name),
                          h('a', {
                            href: artist.external_urls.spotify,
                            target: '_blank',
                            rel: 'noopener noreferrer',
                            className: 'block bg-green-500 hover:bg-green-600 text-black text-xs py-1 px-2 rounded text-center mb-2'
                          }, 'ðŸ”— Open in Spotify'),
                          h('select', {
                            value: categoryName,
                            onChange: (e) => moveArtist(artist.id, categoryName, e.target.value),
                            className: 'w-full bg-gray-700 text-white text-xs py-1 px-2 rounded border border-gray-600 outline-none'
                          }, Object.keys(categories).map(cat => h('option', { key: cat, value: cat }, cat)))
                        )
                      )
                    )
              );
            })
          )
        )
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(SpotifyOrganizer));
  </script>
</body>
</html>
